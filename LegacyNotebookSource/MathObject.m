(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* :Title: MathObject *)
(* :Context: MathObject` *)
(* :Summary: Object oriented programming infrastructure *)
(* :Author: Mark A. Caprio, Department of Physics, University of Notre Dame *)
(* :Copyright: Copyright 2011, Mark A. Caprio *)
(* :Package Version: 1.0 *)
(* :Mathematica Version: 8.0 *)
(* :History: May 2011. Initiated.*)


(* :Discussion: To use the package, the contexts "MathObject`", "MathObject`Methods`", and "MathObject`InstanceData`" should all be in the $ContextPath.  

For interactive use: It always suffices to evaluate Get["MathObject`"], though this will cause the package to be reloaded unnecessarily if already loaded.  It normally suffices to evaluate Needs["MathObject`"], but this will fail to add the subcontexts to the $ContextPath if the package has already been loaded, say, privately to another package.  The completely proper way to load the package is through 

	Needs["MathObject`"];Needs[""MathObject`Methods`"];Needs["MathObject`InstanceData`"];

For internal use by a package: These Needs calls should be evaluated after BeginPackage.

For both internal use by a package *and* for subsequent external use outside the package: It is necessary to evaluate

BeginPackage["...",{MathObject`","MathObject`Methods`","MathObject`InstanceData`",...}]

Major limitation: Method names are in globally accessible namespace and therefore can easily be hidden, e.g., by a local symbol of the same name within a Module.  For example:

Module[
{x},
x=27;
Object@x[]; (* FAILS *)
];
*)


BeginPackage[
"MathObject`",
{"MathObject`Methods`","MathObject`InstanceData`"}
];


Unprotect[Evaluate[$Context<>"*"]];


Object::usage="Object[name] signifies an object of the given name.";
DeclareClass::usage="DeclareClass[class,[parent,]{data1,data2,...},{method1,method2,...}] declares a class of objects, with given members.";
Destroy::usage="Destroy[object] destroys object.  Destruction is carried out by executing a generic destruction function, which in turn invokes the user-defined destructor as one step in the process.";
SetObjectData::usage="SetObjectData[o2,o1] populates all data fields in o2 with the values assigned for o1.  The object o1 must be of the same class as o2 or a daughter class, so insure that all these fields are present.";
ObjectExistsQ::usage="ObjectExistsQ[object] returns True if object is defined, i.e., has been created and not subsequently destroyed.";
ObjectClass::usage="ObjectClass[object] returns the class type of object.";
ObjectName::usage="ObjectName[object] returns the name of object.  (This is an expression, not necessarily a string.)";
ShowObject::usage="ShowObject[object] displays diagnostic information for object.";
ClassAncestry::usage="ClassAncestry[class] returns a list {...,grandparent,parent,class} of the class and its ancestors.";
ClassPattern::usage="ClassPattern[class] matches the class name of the given class or any descended class.";
ObjectPattern::usage="ObjectPattern[class] matches any object of the given class or any descended class.";
ObjectNamePattern::usage="ObjectNamePattern[class] matches the *name* of any object of the given class or any descended class.";
ScopeObjects::usage="ScopeObjects[body] evaluates body, and afterwards destroys all new objects remaining from the evaluation of body.";
ClearObjects::usage="ClearObjects[] removes all object instance data and clears the list of registered objects, without calling destructors.";
ConstructorWrapper::usage="MathObject internal implementation function.  External access is only needed in special circumstances for defining nonstandard syntaxes for calling the constructor.";


$ObjectClass::usage="Global storage for Object (not intended for direct access by user but visible for diagnostic purposes).";
$ObjectInstanceIdentifier::usage="Global storage for Object (not intended for direct access by user but visible for diagnostic purposes).";
$ObjectReference::usage="Global storage for Object (not intended for direct access by user but visible for diagnostic purposes).";
$ObjectRegistry::usage="Global registry of created objects (not intended for direct access by user but visible for diagnostic purposes).";


$ObjectMethodContext="MathObject`Methods`";
$ObjectInstanceContext="MathObject`InstanceData`";


$ObjectRegistry={};


Begin["`Private`"];





ListToString[l_List]:=StringJoin@@Riffle[ToString/@l,","];


Options[DeclareClass]={Replace->False};


DeclareClass[Class_Symbol,Parent_Symbol:None,DataMemberNamesP:{___String},MethodNamesP:{___String},OptionsPattern[]]:=Module[
{s,DataMemberNames,MethodNames,MutatorAccessorMethods,ExplicitMethods},

(* inherit data member and method names if applicable *)
DataMemberNames=Join[
DataMemberNamesP,
If[Parent===None,{},ClassDataMemberNames[Parent]]
];
MethodNames=Join[
MethodNamesP,
If[Parent===None,{},ClassMethodNames[Parent]]
];

(* constructor invocation syntax *)
(* no name -- Class[args] *)
Class/:HoldPattern[Class[Args___]]:=ConstructorWrapper[Class,Object[None]][Args];
(* name -- Class[[name]][args], or case of no name accepted as Class[[]][args] *)
(* Note: Intermediate reference to ConstructorWrapper[] without [Args] necessary sinceis since the definition
Class/:HoldPattern[Class[[n_:None]][Args___]]:=ConstructorWrapper[Class,Object[n]][Args];
places Class at too deep a level to be matched. *)
Class/:HoldPattern[Class[[n_:None]]]:=ConstructorWrapper[Class,Object[n]];

(* define data member mutators and accessors *)
MutatorAccessorMethods=Table[
With[
{
SetMethod=ToExpression[$ObjectMethodContext<>"Set"<>s],
GetMethod=ToExpression[$ObjectMethodContext<>"Get"<>s],
MemberIdentifier=ToExpression[$ObjectInstanceContext<>ToString[Class]<>"$"<>s]
},

SetMethod[Class,Self_Object][Value_]:=($ObjectInstanceIdentifier[Self][MemberIdentifier]=Value;Null);
GetMethod[Class,Self_Object][]:=($ObjectInstanceIdentifier[Self][MemberIdentifier]);
{SetMethod,GetMethod}
],
{s,DataMemberNames}
];

(* define symbols for explicit methods *)
ExplicitMethods=Table[
ToExpression[$ObjectMethodContext<>s],
{s,MethodNames}
];

(* save data member and method lists *)
ClassDataMemberNames[Class]=DataMemberNames;
ClassMethodNames[Class]=MethodNames;
ClassMethods[Class]=Flatten[{MutatorAccessorMethods,ExplicitMethods}];
ClassParent[Class]=Parent;

(* record clobbering permission for this class *)
ClassAllowClobber[Class]=OptionValue[Replace];

(* return Null *)
Null
];


General::objdupl="Cannot create object `1`[[`2`]], since an object named \"`2`\" already exists (as an instance of class `3`).";
General::objsyntax="Missing or unexpected arguments in `1``2`[`3`].  (The given arguments do not match any of the definitions for the constructor for class `1`.)";


UniqueObjectBaseName=$ObjectInstanceContext<>"Object$";


ConstructorWrapper[Class_Symbol,AlmostSelf:Object[AlmostName_]][Args___]:=Module[
{Self,Name,NameArgumentString,Result,Aborted},

(* obtain object name if given as None *)
Name=If[
AlmostName===None,
Unique[UniqueObjectBaseName],
AlmostName
];
Self=Object[Name];

(* check for duplicate creation *)
If[
ObjectExistsQ[Self],
If[
ClassAllowClobber[ObjectClass[Self]],

(* if clobbering is allowed for class of *previously-existing* instance, destroy existing instance *)
Destroy[Self],

(* else fail at creation *)
Message[Class::objdupl,Class,Name,ObjectClass[Self]];
OnCreationFailure[Class,Self][Args];
Return[$Failed]

]
];

(* define instance metadata *)
$ObjectClass[Self]=Class;
$ObjectInstanceIdentifier[Self]=Unique[$ObjectInstanceContext<>"Instance$"];
$ObjectReference[$ObjectInstanceIdentifier[Self]]=Self;

(* do constructor body *)
(* evaluate body *)
Aborted=False;
CheckAbort[
Result=Constructor[Class,Self][Args],
Aborted=True
];

(* check for creation failure due to no constructor match *)
If[
MatchQ[Result,Constructor[_,_][___]],
NameArgumentString=Switch[
AlmostName,
None,"",
_,StringJoin["\[LeftDoubleBracket]",ToString[AlmostName],"\[RightDoubleBracket]"]
];
Message[Class::objsyntax,Class,NameArgumentString,ListToString[{Args}]];
ClearObjectData[Class,Self];
OnCreationFailure[Class,Self][];
Return[$Failed]
];

(* check for creation failure due to abort in constructor *)
If[
Aborted,
ClearObjectData[Class,Self];
Abort[];
Return[$Aborted]
];

(* register object *)
$ObjectRegistry=Union[$ObjectRegistry,{Self}];

(* return object *)
Self
];


ClearObjectData[Class_Symbol,Self:Object[n_]]:=Module[
{},

(* clear member data *)
Clear[Evaluate[$ObjectInstanceIdentifier[Self]]];

(* clear metadata *)
$ObjectReference[$ObjectInstanceIdentifier[Self]]=.;
$ObjectInstanceIdentifier[Self]=.;
$ObjectClass[Self]=.;
];


(*General::objdestroy="Attempting to destroy object `1` when this object does not exist.";*)


Destroy[Self:Object[A_]]:=Module[
{Class},

(* check that object exists in order to be destroyed *)
If[
!ObjectExistsQ[Self],
(*Message[General::objdestroy,Self];*)
Return[]
];

(* identify class *)
Class=ObjectClass[Self];

(* do destructor body *)
(* Note: If no explicit Destructor is defined, this is simply a no-op. *)
Destructor[Class,Self][];

(* delete all object member data and metadata *)
ClearObjectData[Class,Self];

(* deregister object *)
$ObjectRegistry=Complement[$ObjectRegistry,{Self}];

(* return Null *)
Null
];


Object/:HoldPattern[(Self:Object[A_])@((Method_Symbol)[Args___])]:=MethodWrapper[Self,Method,Args];


Object::objaccess="Cannot complete method call `2`@`3`[`4`] since object does not exist.";
General::objmethod="Cannot complete method call `2`@`3`[`4`] since no method named `3` is defined for class `1`.";
General::objmethodsyntax="Cannot complete method call `2`@`3`[`4`] since given arguments do not match any of the definitions for method `3`.";


MethodWrapper[Self:Object[A_],Method_Symbol,Args___]:=Module[
{Class,Result,Msg},

(* validate object *)
If[
!ObjectExistsQ[Self],
Message[Object::objaccess,None,Self,Method,ListToString[{Args}]];
Return[$Failed]
];
Class=ObjectClass[Self];

(* validate method name *)
If[
!MemberQ[ClassMethods[Class],Method],
With[{ClassSymbol=Class},
Message[ClassSymbol::objmethod,Class,Self,Method,ListToString[{Args}]]
]; (* Note: If use Class::objmember directly, message name fails to resolve properly. *)
Return[$Failed]
];

(* invoke method *)
Result=Method[Class,Self][Args];

(* DEBUG: Print[{Method,Context[Method],Class,Context[Class]}];Print[Result]; *)

(* verify method call was matched and evaluated *)
If[
MatchQ[Result,Method[_,_][___]],
With[{ClassSymbol=Class},
Message[ClassSymbol::objmethodsyntax,Class,Self,Method,ListToString[{Args}]]
];
Return[$Failed]
];

(* return result *)
Result
];


SetObjectData::ancestry="Source object `1` is not of the same class as `2` or of a descendent class thereof.";


SetObjectData[o2_Object,o1_Object]:=Module[
{},

(* check ancestry of source object *)
If[
!MatchQ[o1,ObjectPattern[ObjectClass[o2]]],
Message[SetObjectData::ancestry,o1,o2];
Return[]
];

(* do copy *)
Do[
With[
{
SetMethod=ToExpression[$ObjectMethodContext<>"Set"<>s],
GetMethod=ToExpression[$ObjectMethodContext<>"Get"<>s]
},

o2@SetMethod[o1@GetMethod[]]
],
{s,ClassDataMemberNames[ObjectClass[o2]]}
];
];


ObjectExistsQ[Self:Object[A_]]:=(Head[$ObjectClass[Self]]=!=$ObjectClass);


ObjectName[Self:Object[A_]]:=A;


ObjectClass::noclass="Attempting to determine class of object `1` when this object does not exist.";


ObjectClass[Self_Object]:=Module[
{},

(* check that object created *)
If[
!ObjectExistsQ[Self],
Message[ObjectClass::noclass,Self];
Return[]
];

(* retrieve class *)
$ObjectClass[Self]
];


ShowObject[Self_Object]:=Module[
{},

Print["Object name: ",ObjectName[Self]];
If[
!ObjectExistsQ[Self],
Print["Object not defined."];
Return[]
];

Print["  ","Instance identifier: ",$ObjectInstanceIdentifier[Self]];
Print["  ","Class: ",ObjectClass[Self]];
(*Definition[Evaluate[$ObjectInstanceIdentifier[Self]]]*)
Print["  ",InputForm[Replace[
DownValues[Evaluate[$ObjectInstanceIdentifier[Self]]],
{x_:>(x[[1,1,1]]->x[[2]])},
{1}
]]]
];


ClassAncestry::noclass="Ancestry requested for undefined class `1`.";


ClassAncestry[Class_Symbol]/;MatchQ[ClassParent[Class],None]:={Class};
ClassAncestry[Class_Symbol]/;MatchQ[ClassParent[Class],Except[None,_Symbol]]:=Append[ClassAncestry[ClassParent[Class]],Class];
ClassAncestry[Class_Symbol]/;MatchQ[ClassParent[Class],Except[_Symbol]]:=(Message[ClassAncestry::noclass,Class];{});


ClassPattern[Class_Symbol]:=(_Symbol)?(MatchQ[ClassParent[#],_Symbol]&&MemberQ[ClassAncestry[#],Class]&);


ObjectPattern[Class_Symbol]:=(_Object)?(ObjectExistsQ[#]&&MemberQ[ClassAncestry[ObjectClass[#]],Class]&);


ObjectNamePattern[Class_Symbol]:=_?(ObjectExistsQ[Object[#]]&&MemberQ[ClassAncestry[ObjectClass[Object[#]]],Class]&);


SetAttributes[ScopeObjects,HoldAll];


ScopeObjects::numargs="ScopeObjects must be called with exactly one argument.";
ScopeObjects[_,__]:=Message[ScopeObjects::numargs];


(*
ScopeObjects[Body_]:=Module[
{
$ObjectRegistry0,Self,
EvaluatedBody,Aborted
},

AbortProtect[

(* record prior object registry *)
$ObjectRegistry0=$ObjectRegistry;

(* evaluate body *)
Aborted=False;
CheckAbort[
EvaluatedBody=Body,
Aborted=True
];

(* destroy any new objects which still exist *)
(* DEBUG: Print["ScopeObject cleanup: ",$ObjectRegistry0,$ObjectRegistry,Complement[$ObjectRegistry,$ObjectRegistry0]];*)
Do[
Destroy[Self],
{Self,Complement[$ObjectRegistry,$ObjectRegistry0]}
];
];

(* return value *)
(* passes through abort, and also explicitly returns $Aborted in case Abort[] is suppressed *)
If[Aborted,Abort[];$Aborted,EvaluatedBody]
];
*)


ScopeObjects[Body_]:=Module[
{
$ObjectRegistry0,Self,
EvaluatedBody,Aborted
},

Internal`WithLocalSettings[
(* initialization code*)
(* record prior object registry *)
$ObjectRegistry0=$ObjectRegistry,

(* body code*)
Body,

(* cleanup code *)
(* destroy any new objects which still exist *)
(* DEBUG: Print["ScopeObject cleanup: ",$ObjectRegistry0,$ObjectRegistry,Complement[$ObjectRegistry,$ObjectRegistry0]];*)
Do[
Destroy[Self],
{Self,Complement[$ObjectRegistry,$ObjectRegistry0]}
];
]
];


ClearObjects[]:=Module[
{},
$ObjectRegistry={};
Quiet[
Remove["MathObject`InstanceData`*"],
{Remove::rmnsm}
]
]


End[];


Protect[Evaluate[$Context<>"*"]];
Unprotect[Evaluate[$Context<>"$*"]];
EndPackage[];
